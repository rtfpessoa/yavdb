---
- id: nodesecurity:npm:tunnel-agent:2018-04-25
  title: Memory Exposure
  description: |-
    Versions of `tunnel-agent` before 0.6.0 are vulnerable to memory exposure.

    This is exploitable if user supplied input is provided to the auth value and is a number.

    Proof-of-concept:
    ```js
    require('request')({
      method: 'GET',
      uri: 'http://www.example.com',
      tunnel: true,
      proxy:{
        protocol: 'http:',
        host:'127.0.0.1',
        port:8080,
        auth:USERSUPPLIEDINPUT // number
      }
    });
    ```
  affected_package: tunnel-agent
  vulnerable_versions:
  - "<0.6.0"
  patched_versions:
  - ">=0.6.0"
  severity: medium
  package_manager: npm
  credit:
  - Сковорода Никита Андреевич
  references:
  - |-
    https://github.com/request/tunnel-agent/commit/9ca95ec7219daface8a6fc2674000653de0922c0)
    https://gist.github.com/ChALkeR/fd6b2c445834244e7d440a043f9d2ff4)
  source_url: https://nodesecurity.io/advisories/598
- id: snykio:npm:tunnel-agent:2017-03-04
  title: Uninitialized Memory Exposure
  description: |
    [`tunnel-agent`][1] is HTTP proxy tunneling agent. Affected versions of
    the package are vulnerable to Uninitialized Memory Exposure.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is used to set the *proxy.auth* option of a request `request`
    and results in a possible uninitialized memory exposures in the request
    body.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/tunnel-agent
    [2]: https://snyk.io/blog/exploiting-buffer/
    \n[`tunnel-agent`][1] is HTTP proxy tunneling agent. Affected versions of
    the package are vulnerable to Uninitialized Memory Exposure.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is used to set the *proxy.auth* option of a request `request`
    and results in a possible uninitialized memory exposures in the request
    body.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/tunnel-agent
    [2]: https://snyk.io/blog/exploiting-buffer/
    \n[`tunnel-agent`][1] is HTTP proxy tunneling agent. Affected versions of
    the package are vulnerable to Uninitialized Memory Exposure.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is used to set the *proxy.auth* option of a request `request`
    and results in a possible uninitialized memory exposures in the request
    body.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/tunnel-agent
    [2]: https://snyk.io/blog/exploiting-buffer/
    \n[`tunnel-agent`][1] is HTTP proxy tunneling agent. Affected versions of
    the package are vulnerable to Uninitialized Memory Exposure.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is used to set the *proxy.auth* option of a request `request`
    and results in a possible uninitialized memory exposures in the request
    body.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/tunnel-agent
    [2]: https://snyk.io/blog/exploiting-buffer/
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `tunnel-agent`\'s `request` construction uses the default `Buffer`
    constructor as-is, making it easy to append uninitialized memory to an
    existing list. If the value of the buffer list is exposed to users, it
    may expose raw server side memory, potentially holding secrets, private
    data and code. This is a similar vulnerability to the infamous
    [`Heartbleed`][1] flaw in OpenSSL.

    #### Proof of concept by ChALkeR   {#proof-of-concept-by-chalker}

        require('request')({
          method: 'GET',
          uri: 'http://www.example.com',
          tunnel: true,
          proxy:{
              protocol: 'http:',
              host:"127.0.0.1",
              port:8080,
              auth:80
          }
        });

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
  affected_package: tunnel-agent
  vulnerable_versions:
  - "<0.6.0"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-201
  credit:
  - ChALkeR
  references:
  - https://gist.github.com/ChALkeR/fd6b2c445834244e7d440a043f9d2ff4
  - https://github.com/request/tunnel-agent/commit/9ca95ec7219daface8a6fc2674000653de0922c0
  source_url: https://snyk.io/vuln/npm:tunnel-agent:20170305
