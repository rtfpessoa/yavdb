---
- id: nodesecurity:npm:floody:2018-04-25
  title: Remote Memory Exposure
  description: "Versions of `floody` before 0.1.1 are vulnerable to remote memory
    exposure.\n\n.write(number)` in the affected `floody` versions passes a number
    to Buffer constructor, appending a chunk of uninitialized memory.\n\nProof of
    Concept: \n\n```\nvar f = require('floody')(process.stdout); \nf.write(USERSUPPLIEDINPUT);
    \n'f.stop();"
  affected_package: floody
  vulnerable_versions:
  - "<0.1.1"
  patched_versions:
  - ">=0.1.1"
  severity: medium
  package_manager: npm
  credit:
  - Сковорода Никита Андреевич
  references:
  - https://github.com/soldair/node-floody/commit/6c44722312131f4ac8a1af40f0f861c85efe01b0)
  source_url: https://nodesecurity.io/advisories/601
- id: snykio:npm:floody:2016-01-15
  title: Uninitialized Memory Exposure
  description: |
    [`floody`][1] combines floods of small stream writes while not delaying
    or buffering writes when not flooded.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is provided to the `write()` method and results in the
    concatenation of uninitialized memory to the buffer collection.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/floody
    [2]: https://snyk.io/blog/exploiting-buffer/
    \n[`floody`][1] combines floods of small stream writes while not delaying
    or buffering writes when not flooded.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is provided to the `write()` method and results in the
    concatenation of uninitialized memory to the buffer collection.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/floody
    [2]: https://snyk.io/blog/exploiting-buffer/
    \n[`floody`][1] combines floods of small stream writes while not delaying
    or buffering writes when not flooded.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is provided to the `write()` method and results in the
    concatenation of uninitialized memory to the buffer collection.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/floody
    [2]: https://snyk.io/blog/exploiting-buffer/
    \n[`floody`][1] combines floods of small stream writes while not delaying
    or buffering writes when not flooded.

    A possible memory disclosure vulnerability exists when a value of type
    `number` is provided to the `write()` method and results in the
    concatenation of uninitialized memory to the buffer collection.

    This is a result of unobstructed use of the `Buffer` constructor, whose
    [insecure default constructor increases the odds of memory leakage][2].



    [1]: https://www.npmjs.com/package/floody
    [2]: https://snyk.io/blog/exploiting-buffer/
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
    \nConstructing a `Buffer` class with integer `N` creates a `Buffer` of
    length `N` with raw (not \"zero-ed\") memory.

    In the following example, the first call would allocate 100 bytes of
    memory, while the second example will allocate the memory needed for the
    string \"100\":

        // uninitialized Buffer of length 100
        x = new Buffer(100);
        // initialized Buffer with value of '100'
        x = new Buffer('100');

    `floody` uses the default `Buffer` constructor as-is, making it easy to
    append uninitialized memory to an existing list. If the value of the
    buffer list is exposed to users, it may expose raw server side memory,
    potentially holding secrets, private data and code. This is a similar
    vulnerability to the infamous [`Heartbleed`][1] flaw in OpenSSL.

    **PoC by ChALKeR:**

        var f = require('floody')(process.stdout); f.write(1000); f.stop()

    You can read more about the insecure `Buffer` behavior [on our blog][2].

    Similar vulnerabilities were discovered in [request][3], [mongoose][4],
    [ws][5] and [sequelize][6].



    [1]: http://heartbleed.com/
    [2]: https://snyk.io/blog/exploiting-buffer/
    [3]: https://snyk.io/vuln/npm:request:20160119
    [4]: https://snyk.io/vuln/npm:mongoose:20160116
    [5]: https://snyk.io/vuln/npm:ws:20160104
    [6]: https://snyk.io/vuln/npm:sequelize:20160115
  affected_package: floody
  vulnerable_versions:
  - "<0.1.1"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-201
  credit:
  - ChALkeR
  source_url: https://snyk.io/vuln/npm:floody:20160115
