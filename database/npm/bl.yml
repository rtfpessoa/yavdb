---
- id: nodesecurity:npm:bl:2018-04-24
  title: Memory Exposure
  description: |-
    Versions of `bl` before 0.9.5 and 1.0.1 are vulnerable to memory exposure.

    `bl.append(number)` in the affected `bl` versions passes a number to Buffer constructor, appending a chunk of uninitialized memory
  affected_package: bl
  vulnerable_versions:
  - "<=0.9.4 || 1.0.0"
  patched_versions:
  - ">=0.9.5 <1.0.0 || >=1.0.1"
  severity: medium
  package_manager: npm
  credit:
  - Feross Aboukhadijeh
  references:
  - https://github.com/rvagg/bl/pull/22)
  source_url: https://nodesecurity.io/advisories/596
- id: snykio:npm:bl:2016-01-19
  title: Uninitialized Memory Exposure
  description: "[bl][1] is a storage object for collections of Node Buffers.\n\nA
    possible memory disclosure vulnerability exists when a value of type\n`number`
    is provided to the `append()` method and results in\nconcatenation of uninitialized
    memory to the buffer collection.\n\nThis is a result of unobstructed use of the
    `Buffer` constructor, whose\ninsecure default constructor increases the odds of
    memory leakage.\n\n\n\n[1]: https://www.npmjs.com/package/bl\n\\n[bl][1] is a
    storage object for collections of Node Buffers.\n\nA possible memory disclosure
    vulnerability exists when a value of type\n`number` is provided to the `append()`
    method and results in\nconcatenation of uninitialized memory to the buffer collection.\n\nThis
    is a result of unobstructed use of the `Buffer` constructor, whose\ninsecure default
    constructor increases the odds of memory leakage.\n\n\n\n[1]: https://www.npmjs.com/package/bl\n\\n[bl][1]
    is a storage object for collections of Node Buffers.\n\nA possible memory disclosure
    vulnerability exists when a value of type\n`number` is provided to the `append()`
    method and results in\nconcatenation of uninitialized memory to the buffer collection.\n\nThis
    is a result of unobstructed use of the `Buffer` constructor, whose\ninsecure default
    constructor increases the odds of memory leakage.\n\n\n\n[1]: https://www.npmjs.com/package/bl\n\\n[bl][1]
    is a storage object for collections of Node Buffers.\n\nA possible memory disclosure
    vulnerability exists when a value of type\n`number` is provided to the `append()`
    method and results in\nconcatenation of uninitialized memory to the buffer collection.\n\nThis
    is a result of unobstructed use of the `Buffer` constructor, whose\ninsecure default
    constructor increases the odds of memory leakage.\n\n\n\n[1]: https://www.npmjs.com/package/bl\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n\\nConstructing
    a `Buffer` class with integer `N` creates a `Buffer` of\nlength `N` with raw (not
    \\\"zero-ed\\\") memory.\n\nIn the following example, the first call would allocate
    100 bytes of\nmemory, while the second example will allocate the memory needed
    for the\nstring \\\"100\\\":\n\n    // uninitialized Buffer of length 100\n    x
    = new Buffer(100);\n    // initialized Buffer with value of '100'\n    x = new
    Buffer('100');\n\n`bl`\\'s `append` function uses the default `Buffer` constructor
    as-is,\nmaking it easy to append uninitialized memory to an existing list. If\nthe
    value of the buffer list is exposed to users, it may expose raw\nserver side memory,
    potentially holding secrets, private data and code.\nThis is a similar vulnerability
    to the infamous [`Heartbleed`][1] flaw\nin OpenSSL.\n\n    const BufferList =
    require('bl')\n    \n    var bl = new BufferList()\n    bl.append(new Buffer('abcd'))\n
    \   bl.append(new Buffer('efg'))\n    bl.append('100')\n    // appends a Buffer
    holding 100 bytes of uninitialized memory\n    bl.append(100)                     \n
    \   bl.append(new Buffer('j'))\n\nYou can read more about the insecure `Buffer`
    behavior [on our blog][2].\n\nSimilar vulnerabilities were discovered in [request][3],
    [mongoose][4],\n[ws][5] and [sequelize][6].\n\n**Note** This is vulnerable only
    for Node &lt;=4\n\n\n\n[1]: http://heartbleed.com/\n[2]: https://snyk.io/blog/exploiting-buffer/\n[3]:
    https://snyk.io/vuln/npm:request:20160119\n[4]: https://snyk.io/vuln/npm:mongoose:20160116\n[5]:
    https://snyk.io/vuln/npm:ws:20160104\n[6]: https://snyk.io/vuln/npm:sequelize:20160115\n"
  affected_package: bl
  vulnerable_versions:
  - "<0.9.5 || >= 1.0.0 <1.0.1"
  severity: medium
  package_manager: npm
  cwe:
  - CWE-201
  credit:
  - Feross Aboukhadijeh
  references:
  - https://github.com/rvagg/bl/pull/22
  - https://github.com/rvagg/bl/compare/v1.0.0...v1.0.1
  - https://snyk.io/blog/exploiting-buffer/
  source_url: https://snyk.io/vuln/npm:bl:20160119
