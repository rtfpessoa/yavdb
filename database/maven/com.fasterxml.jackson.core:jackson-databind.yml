---
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:1009829
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to
    `com.pastdev.httpcomponents.configuration.JndiConfiguration`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating objects from a sequence
    of bytes is called deserialization. *Deserialization of untrusted data*
    ([CWE-502][1]) occurs when an application deserializes untrusted data
    without sufficiently verifying that the resulting data will be valid,
    allowing the attacker to control the state or the flow of the execution.

    `com.fasterxml.jackson.core:jackson-databind` allows deserialization of
    JSON input to Java objects. If an application using this dependency has
    the ability to deserialize a JSON string from an untrusted source, an
    attacker could leverage this vulnerability to conduct deserialization
    attacks.

    Exploitation of unsafe deserialization attacks through
    `jackson-databind` requires the following prerequisites:

    ### 1. The target application allowing JSON user input which is processed by jackson-databind   {#1-the-target-application-allowing-json-user-input-which-is-processed-by-jackson-databind}

    An application using `jackson-databind` is only vulnerable if a
    user-provided JSON data is deserialized.

    ### 2. Polymorphic type handling for properties with nominal type are enabled   {#2-polymorphic-type-handling-for-properties-with-nominal-type-are-enabled}

    Polymorphic type handling refers to the addition of enough type
    information so that the deserializer can instantiate the appropriate
    subtype of a value. Use of \"default typing\" is considered dangerous
    due to the possibility of an untrusted method (gadget) managing to
    specify a class that is accessible through the class-loader and
    therefore, exposing a set of methods and/or fields.

    ### 3. An exploitable gadget class is available for the attacker to leverage   {#3-an-exploitable-gadget-class-is-available-for-the-attacker-to-leverage}

    Gadget chains are specially crafted method sequences that can be created
    by an attacker in order to change the flow of code execution. These
    gadgets are often methods introduced by third-party components which an
    attacker could utilise in order to attack the target application. Not
    every gadget out there is supported by `jackson-databind`. The
    maintainers of `jackson-databind` proactively blacklists possible
    serialization gadgets in an attempt to ensure that it is not possible
    for an attacker to chain gadgets during serialization.

    ### Further reading:   {#further-reading}

    * [On Jackson CVEs: Don’t Panic on Medium][2]
    * [NCC Group Jackson Deserialization WhitePaper][3]
    * [Java Security Best Practices][4]



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
    [3]: https://www.nccgroup.com/globalassets/our-research/us/whitepapers/2018/jackson_deserialization.pdf
    [4]: https://snyk.io/blog/10-java-security-best-practices/
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-24750
  cwe:
  - CWE-502
  disclosed_date: 2020-09-18
  created_date: 2020-09-18
  last_modified_date: 2020-09-18
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2798
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-1009829
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:1047324
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to the class `ignite-jta`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating objects from a sequence
    of bytes is called deserialization. *Deserialization of untrusted data*
    ([CWE-502][1]) occurs when an application deserializes untrusted data
    without sufficiently verifying that the resulting data will be valid,
    allowing the attacker to control the state or the flow of the execution.

    `com.fasterxml.jackson.core:jackson-databind` allows deserialization of
    JSON input to Java objects. If an application using this dependency has
    the ability to deserialize a JSON string from an untrusted source, an
    attacker could leverage this vulnerability to conduct deserialization
    attacks.

    Exploitation of unsafe deserialization attacks through
    `jackson-databind` requires the following prerequisites:

    ### 1. The target application allowing JSON user input which is processed by jackson-databind   {#1-the-target-application-allowing-json-user-input-which-is-processed-by-jackson-databind}

    An application using `jackson-databind` is only vulnerable if a
    user-provided JSON data is deserialized.

    ### 2. Polymorphic type handling for properties with nominal type are enabled   {#2-polymorphic-type-handling-for-properties-with-nominal-type-are-enabled}

    Polymorphic type handling refers to the addition of enough type
    information so that the deserializer can instantiate the appropriate
    subtype of a value. Use of \"default typing\" is considered dangerous
    due to the possibility of an untrusted method (gadget) managing to
    specify a class that is accessible through the class-loader and
    therefore, exposing a set of methods and/or fields.

    ### 3. An exploitable gadget class is available for the attacker to leverage   {#3-an-exploitable-gadget-class-is-available-for-the-attacker-to-leverage}

    Gadget chains are specially crafted method sequences that can be created
    by an attacker in order to change the flow of code execution. These
    gadgets are often methods introduced by third-party components which an
    attacker could utilise in order to attack the target application. Not
    every gadget out there is supported by `jackson-databind`. The
    maintainers of `jackson-databind` proactively blacklists possible
    serialization gadgets in an attempt to ensure that it is not possible
    for an attacker to chain gadgets during serialization.

    ### Further reading:   {#further-reading}

    * [On Jackson CVEs: Don’t Panic on Medium][2]
    * [NCC Group Jackson Deserialization WhitePaper][3]
    * [Java Security Best Practices][4]



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
    [3]: https://www.nccgroup.com/globalassets/our-research/us/whitepapers/2018/jackson_deserialization.pdf
    [4]: https://snyk.io/blog/10-java-security-best-practices/
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.4"
  - ">= 2.7.0 < 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-10650
  cwe:
  - CWE-502
  disclosed_date: 2020-09-29
  created_date: 2020-11-29
  last_modified_date: 2020-11-29
  credit:
  - Srikanth Ramu
  - threedr3am'follower
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2658
  - https://github.com/FasterXML/jackson-databind/pull/2864#issuecomment-701026600
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-1047324
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:1048302
  title: XML External Entity (XXE) Injection
  description: |+
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to XML External Entity
    (XXE) Injection. A flaw was found in FasterXML Jackson Databind, where
    it does not have entity expansion secured properly in the
    `DOMDeserializer` class. The highest threat from this vulnerability is
    data integrity.



    [1]: https://github.com/FasterXML/jackson-databind
    \nXXE Injection is a type of attack against an application that parses XML
    input. XML is a markup language that defines a set of rules for encoding
    documents in a format that is both human-readable and machine-readable.
    By default, many XML processors allow specification of an external
    entity, a URI that is dereferenced and evaluated during XML processing.
    When an XML document is being parsed, the parser can make a request and
    include the content at the specified URI inside of the XML document.

    Attacks can include disclosing local files, which may contain sensitive
    data such as passwords or private user data, using file: schemes or
    relative paths in the system identifier.

    For example, below is a sample XML document, containing an XML element-
    username.

        <?xml version="1.0" encoding="ISO-8859-1"?>
           <username>John</username>
        </xml>
    {: .language-xml}

    An external XML entity - `xxe`, is defined using a system identifier and
    present within a DOCTYPE header. These entities can access local or
    remote content. For example the below code contains an external XML
    entity that would fetch the content of `/etc/passwd` and display it to
    the user rendered by `username`.

        <?xml version="1.0" encoding="ISO-8859-1"?>
        <!DOCTYPE foo [
           <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
           <username>&xxe;</username>
        </xml>
    {: .language-xml}

    Other XXE Injection attacks can access local resources that may not stop
    returning data, possibly impacting application availability and leading
    to Denial of Service.

  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.10.0 < 2.10.5.1"
  - ">= 2.6.0 < 2.6.7.4"
  - ">= 2.9.0 < 2.9.10.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-25649
  cwe:
  - CWE-611
  disclosed_date: 2020-12-04
  created_date: 2020-12-04
  last_modified_date: 2020-12-04
  credit:
  - Unknown
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=1887664
  - https://github.com/FasterXML/jackson-databind/commit/612f971b78c60202e9cd75a299050c8f2d724a59
  - https://github.com/FasterXML/jackson-databind/issues/2589
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-1048302
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:1052449
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to
    `org.apache.commons.dbcp2.datasources.PerUserPoolDataSource`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.10.0.pr1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-35490
  cwe:
  - CWE-502
  disclosed_date: 2020-12-18
  created_date: 2020-12-18
  last_modified_date: 2020-12-18
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2986
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-1052449
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:1052450
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to
    `org.apache.commons.dbcp2.datasources.SharedPoolDataSource`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.10.0.pr1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-35491
  cwe:
  - CWE-502
  disclosed_date: 2020-12-18
  created_date: 2020-12-18
  last_modified_date: 2020-12-18
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2986
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-1052450
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:1054588
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to
    `com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool` (aka
    embedded Xalan in `org.glassfish.web/javax.servlet.jsp.jstl`).



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating objects from a sequence
    of bytes is called deserialization. *Deserialization of untrusted data*
    ([CWE-502][1]) occurs when an application deserializes untrusted data
    without sufficiently verifying that the resulting data will be valid,
    allowing the attacker to control the state or the flow of the execution.

    `com.fasterxml.jackson.core:jackson-databind` allows deserialization of
    JSON input to Java objects. If an application using this dependency has
    the ability to deserialize a JSON string from an untrusted source, an
    attacker could leverage this vulnerability to conduct deserialization
    attacks.

    Exploitation of unsafe deserialization attacks through
    `jackson-databind` requires the following prerequisites:

    ### 1. The target application allowing JSON user input which is processed by jackson-databind   {#1-the-target-application-allowing-json-user-input-which-is-processed-by-jackson-databind}

    An application using `jackson-databind` is only vulnerable if a
    user-provided JSON data is deserialized.

    ### 2. Polymorphic type handling for properties with nominal type are enabled   {#2-polymorphic-type-handling-for-properties-with-nominal-type-are-enabled}

    Polymorphic type handling refers to the addition of enough type
    information so that the deserializer can instantiate the appropriate
    subtype of a value. Use of \"default typing\" is considered dangerous
    due to the possibility of an untrusted method (gadget) managing to
    specify a class that is accessible through the class-loader and
    therefore, exposing a set of methods and/or fields.

    ### 3. An exploitable gadget class is available for the attacker to leverage   {#3-an-exploitable-gadget-class-is-available-for-the-attacker-to-leverage}

    Gadget chains are specially crafted method sequences that can be created
    by an attacker in order to change the flow of code execution. These
    gadgets are often methods introduced by third-party components which an
    attacker could utilise in order to attack the target application. Not
    every gadget out there is supported by `jackson-databind`. The
    maintainers of `jackson-databind` proactively blacklists possible
    serialization gadgets in an attempt to ensure that it is not possible
    for an attacker to chain gadgets during serialization.

    ### Further reading:   {#further-reading}

    * [On Jackson CVEs: Don’t Panic on Medium][2]
    * [NCC Group Jackson Deserialization WhitePaper][3]
    * [Java Security Best Practices][4]



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
    [3]: https://www.nccgroup.com/globalassets/our-research/us/whitepapers/2018/jackson_deserialization.pdf
    [4]: https://snyk.io/blog/10-java-security-best-practices/
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.9.10.8"
  severity: medium
  package_manager: maven
  cve:
  - CVE-2020-35728
  cwe:
  - CWE-502
  disclosed_date: 2020-12-27
  created_date: 2020-12-27
  last_modified_date: 2020-12-27
  credit:
  - bu5yer
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2999
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-1054588
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:174736
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. When Default Typing is enabled for an externally exposed
    JSON endpoint, the service has the mysql-connector-java jar in the
    classpath. An attacker can host a crafted MySQL server reachable by the
    victim and send a crafted JSON message that allows them to read
    arbitrary local files on the server. This occurs due to missing
    `com.mysql.cj.jdbc.admin.MiniAdmin` validation.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.9"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-12086
  cwe:
  - CWE-502
  disclosed_date: 2019-05-17
  created_date: 2019-05-17
  last_modified_date: 2019-05-17
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024
  - https://github.com/FasterXML/jackson-databind/issues/2326
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:31507
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker may exploit this issue by sending a
    maliciously crafted input to the `readValue` method of the
    `ObjectMapper`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.1"
  - ">= 2.7.0 < 2.7.9.1"
  - ">= 2.8.0 < 2.8.9"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-7525
  cwe:
  - CWE-502
  disclosed_date: 2017-04-10
  created_date: 2017-09-14
  last_modified_date: 2017-09-14
  credit:
  - Liao Xinxi
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=1462702
  - https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1
  - https://github.com/FasterXML/jackson-databind/issues/1599
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:31573
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2]).



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.1"
  - ">= 2.7.0 < 2.7.9.1"
  - ">= 2.8.0 < 2.8.10"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-15095
  cwe:
  - CWE-184
  disclosed_date: 2017-06-26
  created_date: 2017-11-09
  last_modified_date: 2017-11-09
  credit:
  - Liao Xinxi
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=1506612
  - https://github.com/FasterXML/jackson-databind/commit/e8f043d1
  - https://github.com/FasterXML/jackson-databind/issues/1680
  - https://github.com/FasterXML/jackson-databind/issues/1737
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:32043
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2]). This is exploitable by sending maliciously crafted
    JSON input to the readValue method of the ObjectMapper, bypassing a
    blacklist that is ineffective if the Spring libraries are available in
    the classpath.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.8.11"
  - ">= 2.9.0 < 2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-17485
  cwe:
  - CWE-502
  disclosed_date: 2018-01-10
  created_date: 2018-01-22
  last_modified_date: 2018-01-22
  credit:
  - Imre Rad
  references:
  - https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf
  - https://github.com/FasterXML/jackson-databind/issues/1855
  - https://github.com/irsl/jackson-rce-via-spel/
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:32044
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2] and [CVE-2017-17485][3]). This is exploitable via two
    different gadgets that bypass a blacklist.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    [3]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.8.11"
  - ">= 2.9.0 < 2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-5968
  cwe:
  - CWE-502
  disclosed_date: 2018-01-18
  created_date: 2018-01-23
  last_modified_date: 2018-01-23
  credit:
  - Rui Chong
  references:
  - https://github.com/FasterXML/jackson-databind/issues/1899
  - https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:32111
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It allows unauthenticated remote code execution because
    of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is
    exploitable by sending maliciously crafted JSON input to the readValue
    method of the ObjectMapper, bypassing a blacklist that is ineffective if
    the `c3p0` libraries are available in the classpath.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.8.11.1"
  - ">= 2.9.0 < 2.9.5"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-7489
  cwe:
  - CWE-502
  disclosed_date: 2018-02-10
  created_date: 2018-02-26
  last_modified_date: 2018-02-26
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2
  - https://github.com/FasterXML/jackson-databind/issues/1931
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:450207
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered in FasterXML
    jackson-databind 2.x through 2.9.9. When Default Typing is enabled
    (either globally or for a specific property) for an externally exposed
    JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath,
    an attacker can send a specifically crafted JSON message that allows
    them to read arbitrary local files on the server.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.4"
  - ">= 2.9.0 < 2.9.9.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-12814
  cwe:
  - CWE-502
  disclosed_date: 2019-06-19
  created_date: 2019-06-19
  last_modified_date: 2019-06-19
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5
  - https://github.com/FasterXML/jackson-databind/issues/2341
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:450917
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data which allows attackers to have a variety of impacts by
    leveraging failure to block the `logback-core` class from polymorphic
    deserialization. Depending on the `classpath` content, remote code
    execution may be possible.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.4"
  - ">= 2.9.0 < 2.9.9.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-12384
  cwe:
  - CWE-502
  disclosed_date: 2019-05-28
  created_date: 2019-06-25
  last_modified_date: 2019-06-25
  credit:
  - College of software Nankai University
  references:
  - https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x
  - https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java
  - https://github.com/FasterXML/jackson-databind/issues/2334
  - https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:455617
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. `SubTypeValidator.java` mishandles default typing when
    `ehcache` is used, leading to remote code execution.



    [1]: https://github.com/FasterXML/jackson-databind
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.4"
  - ">= 2.9.0 < 2.9.9.2"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-14379
  - CVE-2019-14439
  cwe:
  - CWE-502
  disclosed_date: 2019-07-29
  created_date: 2019-07-29
  last_modified_date: 2019-07-29
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2
  - https://github.com/FasterXML/jackson-databind/issues/2387
  - https://github.com/FasterXML/jackson-databind/issues/2389
  - https://github.com/FasterXML/jackson-databind/issues/2395
  - https://snyk.io/blog/jackson-deserialization-vulnerability/
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:467014
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered as
    `com.zaxxer.hikari.HikariDataSource` was not blocked. **Note:** This is
    a different vulnerability than CVE-2019-14540.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  - ">= 2.10.0.pr1 < 2.10.0.pr3"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-16335
  cwe:
  - CWE-502
  disclosed_date: 2019-09-15
  created_date: 2019-09-16
  last_modified_date: 2019-09-16
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db
  - https://github.com/FasterXML/jackson-databind/issues/2449
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:467015
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered as
    `com.zaxxer.hikari.HikariConfig` was not blocked. **Note:** This is a
    different vulnerability than CVE-2019-16335.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  - ">= 2.10.0.pr1 < 2.10.0.pr2"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-14540
  cwe:
  - CWE-502
  disclosed_date: 2019-09-15
  created_date: 2019-09-16
  last_modified_date: 2019-09-16
  credit:
  - iSafeBlue
  references:
  - https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de
  - https://github.com/FasterXML/jackson-databind/issues/2410
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:467016
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. None



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  - ">= 2.10.0.pr1 < 2.10.0.pr2"
  severity: high
  package_manager: maven
  cwe:
  - CWE-502
  disclosed_date: 2019-09-16
  created_date: 2019-09-16
  last_modified_date: 2019-09-16
  credit:
  - Tatu Saloranta
  references:
  - https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de
  - https://github.com/FasterXML/jackson-databind/issues/2420
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:469674
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered within
    `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not
    blocked. An attacker could leverage this gadget type to perform Remote
    Code Execution attacks through deserialization.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-16942
  cwe:
  - CWE-502
  disclosed_date: 2019-10-01
  created_date: 2019-10-02
  last_modified_date: 2019-10-02
  credit:
  - bsmali4
  references:
  - https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac
  - https://github.com/FasterXML/jackson-databind/issues/2478
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:469676
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered as
    `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could
    leverage this gadget type to perform Remote Code Execution attacks
    through deserialization.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-16943
  cwe:
  - CWE-502
  disclosed_date: 2019-10-01
  created_date: 2019-10-02
  last_modified_date: 2019-10-02
  credit:
  - bsmali4
  references:
  - https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac
  - https://github.com/FasterXML/jackson-databind/issues/2478
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:471943
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered related to
    `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-17267
  cwe:
  - CWE-502
  disclosed_date: 2019-10-07
  created_date: 2019-10-07
  last_modified_date: 2019-10-07
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb
  - https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10
  - https://github.com/FasterXML/jackson-databind/issues/2460
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:472980
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. When Default Typing is enabled for an externally exposed
    JSON endpoint and the service has the apache-log4j-extra (version 1.2.x)
    jar in the classpath, and an attacker can provide a JNDI service to
    access, it is possible to make the service execute a malicious payload.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.9.10.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-17531
  cwe:
  - CWE-502
  disclosed_date: 2019-10-12
  created_date: 2019-10-13
  last_modified_date: 2019-10-13
  credit:
  - Zhangxianhui
  references:
  - https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0
  - https://github.com/FasterXML/jackson-databind/issues/2498
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:540500
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. Two additional `net.sf.ehcache` gadgets are not
    blacklisted.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.2"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-20330
  cwe:
  - CWE-502
  disclosed_date: 2020-01-03
  created_date: 2020-01-03
  last_modified_date: 2020-01-03
  credit:
  - UltramanGaia
  references:
  - https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e
  - https://github.com/FasterXML/jackson-databind/issues/2526
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:548451
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2]). It lacks `xbean-reflect/JNDI` blocking, as
    demonstrated by `org.apache.xbean.propertyeditor.JndiConverter`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.8.11.5"
  - ">= 2.9.0 < 2.9.10.3"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-8840
  cwe:
  - CWE-502
  disclosed_date: 2020-02-09
  created_date: 2020-02-11
  last_modified_date: 2020-02-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/914e7c9f2cb8ce66724bf26a72adc7e958992497
  - https://github.com/FasterXML/jackson-databind/issues/2620
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-548451
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:559094
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data Mishandles the interaction between serialization gadgets
    and typing, related to:

    * `com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig` (aka
      `ibatis-sqlmap`)
    * `br.com.anteros.dbcp.AnterosDBCPConfig` (aka `anteros-core`)
    * `org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig` (aka shaded
      `hikari-config`)



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-9546
  - CVE-2020-9547
  - CVE-2020-9548
  cwe:
  - CWE-502
  disclosed_date: 2020-03-02
  created_date: 2020-03-02
  last_modified_date: 2020-03-02
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/9f4e97019fb0dd836533d0b6198c88787e235ae2
  - https://github.com/FasterXML/jackson-databind/issues/2631
  - https://github.com/FasterXML/jackson-databind/issues/2634
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-559094
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:559106
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2]). It doesn\'t block `common-configuration` JNDI
    classes `org.apache.commons.configuration.JNDIConfiguration` and
    `org.apache.commons.configuration2.JNDIConfiguration`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.3"
  - ">= 2.8.0 < 2.8.11.5"
  - ">= 2.9.0 < 2.9.10.3"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-14892
  - CVE-2019-14893
  cwe:
  - CWE-502
  disclosed_date: 2020-03-02
  created_date: 2020-03-02
  last_modified_date: 2020-03-02
  credit:
  - Pedro Sampaio
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-14892
  - https://github.com/FasterXML/jackson-databind/commit/41b7f9b90149e9d44a65a8261a8deedc7186f6af
  - https://github.com/FasterXML/jackson-databind/issues/2462
  - https://github.com/FasterXML/jackson-databind/issues/2469
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-559106
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:560762
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. The package mishandles the interaction between
    serialization gadgets and typing, related to
    `com.caucho.config.types.ResourceRef` (aka `caucho-quercus`).

    Note: This vulnerability does not affect release `2.10.0` onward.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-10673
  cwe:
  - CWE-502
  disclosed_date: 2020-03-18
  created_date: 2020-03-18
  last_modified_date: 2020-03-18
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/1645efbd392989cf015f459a91c999e59c921b15
  - https://github.com/FasterXML/jackson-databind/issues/2660
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-560762
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:560766
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. The package mishandles the interaction between
    serialization gadgets and typing, related to
    `org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory`
    (aka `aries.transaction.jms`).

    Note: This vulnerability does not affect release `2.10.0` onward.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-10672
  cwe:
  - CWE-502
  disclosed_date: 2020-03-18
  created_date: 2020-03-18
  last_modified_date: 2020-03-18
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/592872f4235c7f2a3280725278da55544032f72d
  - https://github.com/FasterXML/jackson-databind/issues/2659
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-560766
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:561362
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. The package mishandles the interaction between
    serialization gadgets and typing, related to gadget
    `javax.swing.JEditorPane`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-10969
  cwe:
  - CWE-502
  disclosed_date: 2020-03-26
  created_date: 2020-03-26
  last_modified_date: 2020-03-26
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2642
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-561362
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:561373
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. The package mishandles the interaction between
    serialization gadgets and typing, related to gadget
    `org.aoju.bus.proxy.provider.remoting.RmiProvider` (aka bus-proxy).



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-10968
  cwe:
  - CWE-502
  disclosed_date: 2020-03-26
  created_date: 2020-03-26
  last_modified_date: 2020-03-26
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2662
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-561373
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:561585
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to gadget
    `org.apache.openjpa.ee.WASRegistryManagedRuntime` (aka openjpa).



    [1]: https://github.com/FasterXML/jackson-databind
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-11113
  cwe:
  - CWE-502
  disclosed_date: 2020-03-31
  created_date: 2020-03-31
  last_modified_date: 2020-03-31
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/e2ba12d5d60715d95105e3e790fc234cfb59893d
  - https://github.com/FasterXML/jackson-databind/issues/2670
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-561585
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:561586
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to gadgets `org.apache.activemq.*` (aka
    activemq-jms, activemq-core, activemq-pool, and activemq-pool-jms).



    [1]: https://github.com/FasterXML/jackson-databind
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-11111
  cwe:
  - CWE-502
  disclosed_date: 2020-03-31
  created_date: 2020-03-31
  last_modified_date: 2020-03-31
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/c14c9f99ed030dbd1440129585f03440c8758a99
  - https://github.com/FasterXML/jackson-databind/issues/2664
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-561586
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:561587
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to gadget
    `org.apache.commons.proxy.provider.remoting.RmiProvider` (aka
    apache/commons-proxy).



    [1]: https://github.com/FasterXML/jackson-databind
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-11112
  cwe:
  - CWE-502
  disclosed_date: 2020-03-31
  created_date: 2020-03-31
  last_modified_date: 2020-03-31
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/05d7e0e13f43e12db6a51726df12c8b4d8040676
  - https://github.com/FasterXML/jackson-databind/issues/2666
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-561587
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:564887
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to `org.apache.commons.jelly.impl.Embedded`
    (aka `commons-jelly`).



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-11620
  cwe:
  - CWE-502
  disclosed_date: 2020-04-08
  created_date: 2020-04-08
  last_modified_date: 2020-04-08
  credit:
  - Tatu Saloranta
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2682
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-564887
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:564888
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to
    `org.springframework.aop.config.MethodLocatingFactoryBean` (aka
    `spring-aop`).



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-11619
  cwe:
  - CWE-502
  disclosed_date: 2020-04-08
  created_date: 2020-04-08
  last_modified_date: 2020-04-08
  credit:
  - Tatu Saloranta
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2680
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-564888
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:570625
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It is possible to conduct a Deserialization attack using
    the `com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool`
    (`xalan2`) class gadget if polymorphic type handling is enabled and an
    application using this package allows user input which gets
    deserialized.

    Note: This vulnerability does not affect release `2.10.0` onward.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.10.0"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-14062
  cwe:
  - CWE-502
  disclosed_date: 2020-05-01
  created_date: 2020-05-29
  last_modified_date: 2020-05-29
  credit:
  - XuYuanzhen
  references:
  - https://github.com/FasterXML/jackson-databind/commit/840eae2ca81c597a0010b2126f32dce17d384b70
  - https://github.com/FasterXML/jackson-databind/issues/2704
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-570625
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:572300
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. The package mishandles the interaction between
    serialization gadgets and typing, related to
    `org.jsecurity.realm.jndi.JndiRealmFactory`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.10.0"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-14195
  cwe:
  - CWE-502
  disclosed_date: 2020-06-14
  created_date: 2020-06-14
  last_modified_date: 2020-06-14
  credit:
  - Al1ex@knownsec
  references:
  - https://github.com/FasterXML/jackson-databind/commit/f6d9c664f6d481703138319f6a0f1fdbddb3a259
  - https://github.com/FasterXML/jackson-databind/issues/2765
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-572300
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:572314
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It is possible to conduct a Deserialization attack using
    the `oadd.org.apache.xalan.lib.sql.JNDIConnectionPool` (`apache/drill`)
    class gadget if polymorphic type handling is enabled and an application
    using this package allows user input which gets deserialized.

    Note: This vulnerability does not affect release `2.10.0` onward.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.10.0"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-14060
  cwe:
  - CWE-502
  disclosed_date: 2020-06-15
  created_date: 2020-06-15
  last_modified_date: 2020-06-15
  credit:
  - Topsec
  references:
  - https://github.com/FasterXML/jackson-databind/commit/d1c67a0396e84c08d0558fbb843b5bd1f26e1921
  - https://github.com/FasterXML/jackson-databind/issues/2688
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-572314
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:572316
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It is possible to conduct a Deserialization attack using
    any of the following class gadget available within
    `weblogic/oracle-aqjms` if polymorphic type handling is enabled and an
    application using this package allows user input which gets
    deserialized.

    * oracle.jms.AQjmsQueueConnectionFactory
    * oracle.jms.AQjmsXATopicConnectionFactory
    * oracle.jms.AQjmsTopicConnectionFactory
    * oracle.jms.AQjmsXAQueueConnectionFactory
    * oracle.jms.AQjmsXAConnectionFactory

    Note: This vulnerability does not affect release `2.10.0` onward.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.10.0"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-14061
  cwe:
  - CWE-502
  disclosed_date: 2020-06-15
  created_date: 2020-06-15
  last_modified_date: 2020-06-15
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2698
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-572316
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:608664
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It mishandles the interaction between serialization
    gadgets and typing, related to
    `br.com.anteros.dbcp.AnterosDBCPDataSource` (aka Anteros-DBCP).



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2020-24616
  cwe:
  - CWE-502
  disclosed_date: 2020-08-26
  created_date: 2020-08-26
  last_modified_date: 2020-08-26
  credit:
  - Tatu Saloranta
  references:
  - https://github.com/FasterXML/jackson-databind/issues/2814
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-608664
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72445
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attack, if the user is handling untrusted content or using the `Default
    Typing` feature. an incomplete fix for the [CVE-2017-7525][2]
    deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-12022`) is not identical to
    `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14723` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.4"
  - ">= 2.8.0 < 2.8.11.2"
  - ">= 2.9.0 < 2.9.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-12022
  cwe:
  - CWE-502
  disclosed_date: 2018-05-29
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1
  - https://github.com/FasterXML/jackson-databind/issues/2052
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72446
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It may allow content exfiltration (remote access by
    sending contents over ftp) when untrusted content is deserialized with
    default typing enabled. This vulnerability is due to an incomplete fix
    for the [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-11307`) is not identical to
    `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722` and `CVE-2018-14723`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0.RC1 < 2.7.9.4"
  - ">= 2.8.0.rc1 < 2.8.11.2"
  - ">= 2.9.0 < 2.9.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-11307
  cwe:
  - CWE-502
  disclosed_date: 2018-05-10
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737
  - https://github.com/FasterXML/jackson-databind/issues/2032
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72447
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attack, if the user is handling untrusted content or using the `Default
    Typing` feature. This vulnerability is due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-12023`) is not identical to
    `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0-RC1 < 2.7.9.4"
  - ">= 2.8.0.rc1 < 2.8.11.2"
  - ">= 2.9.0 < 2.9.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-12023
  cwe:
  - CWE-502
  disclosed_date: 2018-05-29
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a
  - https://github.com/FasterXML/jackson-databind/issues/2058
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72448
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] library which contains
    the general-purpose data-binding functionality and tree-model for
    Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks via the `slf4j-ext` gadget due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14718`) is not identical to
    `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14718
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72449
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform an XML External Entity (XXE)
    Injection via the `JDK` classes due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14720`) is not identical to
    `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14720
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72450
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] library which contains
    the general-purpose data-binding functionality and tree-model for
    Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution attack
    via the `blaze-ds-opt` gadget due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14719`) is not identical to
    `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14719
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72451
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] library which contains
    the general-purpose data-binding functionality and tree-model for
    Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A malicious user could perform a SSRF attack via the
    `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525][2]
    deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14721`) is not identical to
    `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14721
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72882
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks due to not blocking the `jboss-common-core` class from
    polymorphic deserialization.

    **Note** This vulnerability (`CVE-2018-19362`) is not identical to
    `CVE-2018-19360` and `CVE-2018-19361`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.8"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-19362
  cwe:
  - CWE-502
  disclosed_date: 2019-01-02
  created_date: 2019-01-03
  last_modified_date: 2019-01-03
  credit:
  - Wuguixiong
  references:
  - https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b
  - https://github.com/FasterXML/jackson-databind/issues/2186
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72883
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks due to not blocking the `axis2-transport-jms` class from
    polymorphic deserialization.

    **Note** This vulnerability (`CVE-2018-19360`) is not identical to
    `CVE-2018-19362` and `CVE-2018-19361`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.8"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-19360
  cwe:
  - CWE-502
  disclosed_date: 2019-01-02
  created_date: 2019-01-03
  last_modified_date: 2019-01-03
  credit:
  - Wuguixiong
  references:
  - https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b
  - https://github.com/FasterXML/jackson-databind/issues/2186
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72884
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks due to not blocking the `axis2-transport-jms` class from
    polymorphic deserialization.

    **Note** This vulnerability (`CVE-2018-19361`) is not identical to
    `CVE-2018-19362` and `CVE-2018-19360`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.8"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-19361
  cwe:
  - CWE-502
  disclosed_date: 2019-01-02
  created_date: 2019-01-03
  last_modified_date: 2019-01-03
  credit:
  - Wuguixiong
  references:
  - https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b
  - https://github.com/FasterXML/jackson-databind/issues/2186
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2017-17485
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'FasterXML jackson-databind through 2.8.10 and 2.9.x through 2.9.3
    allows unauthenticated remote code execution because of an incomplete fix for
    the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously
    crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist
    that is ineffective if the Spring libraries are available in the classpath.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2.8'
  - '2.9'
  - "<=2.8.10"
  - "<=2.9.3"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.11"
  - ">=2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-17485
  credit:
  - Victims CVE Database
  references:
  - http://www.securityfocus.com/archive/1/archive/1/541652/100/0/threaded
  - https://access.redhat.com/errata/RHSA-2018:0116
  - https://access.redhat.com/errata/RHSA-2018:0342
  - https://access.redhat.com/errata/RHSA-2018:0478
  - https://access.redhat.com/errata/RHSA-2018:0479
  - https://access.redhat.com/errata/RHSA-2018:0480
  - https://access.redhat.com/errata/RHSA-2018:0481
  - https://access.redhat.com/errata/RHSA-2018:1447
  - https://access.redhat.com/errata/RHSA-2018:1448
  - https://access.redhat.com/errata/RHSA-2018:1449
  - https://access.redhat.com/errata/RHSA-2018:1450
  - https://access.redhat.com/errata/RHSA-2018:1451
  - https://github.com/FasterXML/jackson-databind/issues/1855
  - https://github.com/irsl/jackson-rce-via-spel/
  - https://security.netapp.com/advisory/ntap-20180201-0003/
  - https://www.debian.org/security/2018/dsa-4114
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2017/17485.yaml
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2017-7525
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'A deserialization flaw was discovered in the jackson-databind which
    could allow an unauthenticated user to perform code execution by sending the maliciously
    crafted input to the readValue method of the ObjectMapper.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2'
  - '2.8'
  - '2.9'
  - "<=2.7.0"
  - "<=2.8.9"
  - "<=2.9.0"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.10"
  - ">=2.9.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-7525
  credit:
  - Victims CVE Database
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=1462702
  - https://github.com/FasterXML/jackson-databind/issues/1737
  - https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2017/7525.yaml
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2018-5968
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'FasterXML jackson-databind through 2.8.11 and 2.9.x through 2.9.3
    allows unauthenticated remote code execution because of an incomplete fix for
    the CVE-2017-7525 and CVE-2017-17485 deserialization flaws. This is exploitable
    via two different gadgets that bypass a blacklist.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2.8'
  - '2.9'
  - "<=2.8.11"
  - "<=2.9.3"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.11.1"
  - ">=2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-5968
  credit:
  - Victims CVE Database
  references:
  - https://access.redhat.com/errata/RHSA-2018:0478
  - https://access.redhat.com/errata/RHSA-2018:0479
  - https://access.redhat.com/errata/RHSA-2018:0480
  - https://access.redhat.com/errata/RHSA-2018:0481
  - https://access.redhat.com/errata/RHSA-2018:1525
  - https://github.com/FasterXML/jackson-databind/issues/1899
  - https://security.netapp.com/advisory/ntap-20180423-0002/
  - https://www.debian.org/security/2018/dsa-4114
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2018/5968.yaml
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2018-7489
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'FasterXML jackson-databind before 2.8.11.1 and 2.9.x before 2.9.5
    allows unauthenticated remote code execution because of an incomplete fix for
    the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously
    crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist
    that is ineffective if the c3p0 libraries are available in the classpath.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2.8'
  - '2.9'
  - "<2.8.11.1"
  - "<=2.9.4"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.11.1"
  - ">=2.9.5"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-7489
  credit:
  - Victims CVE Database
  references:
  - http://www.oracle.com/technetwork/security-advisory/cpuapr2018-3678067.html
  - http://www.securityfocus.com/bid/103203
  - http://www.securitytracker.com/id/1040693
  - https://access.redhat.com/errata/RHSA-2018:1447
  - https://access.redhat.com/errata/RHSA-2018:1448
  - https://access.redhat.com/errata/RHSA-2018:1449
  - https://access.redhat.com/errata/RHSA-2018:1450
  - https://access.redhat.com/errata/RHSA-2018:1451
  - https://access.redhat.com/errata/RHSA-2018:1786
  - https://github.com/FasterXML/jackson-databind/issues/1931
  - https://security.netapp.com/advisory/ntap-20180328-0001/
  - https://www.debian.org/security/2018/dsa-4190
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2018/7489.yaml
