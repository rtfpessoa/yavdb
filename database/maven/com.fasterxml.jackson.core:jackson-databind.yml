---
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:174736
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. When Default Typing is enabled for an externally exposed
    JSON endpoint, the service has the mysql-connector-java jar in the
    classpath. An attacker can host a crafted MySQL server reachable by the
    victim and send a crafted JSON message that allows them to read
    arbitrary local files on the server. This occurs due to missing
    `com.mysql.cj.jdbc.admin.MiniAdmin` validation.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.9"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-12086
  cwe:
  - CWE-502
  disclosed_date: 2019-05-17
  created_date: 2019-05-17
  last_modified_date: 2019-05-17
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024
  - https://github.com/FasterXML/jackson-databind/issues/2326
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:31507
  title: Deserialization of Untrusted Data
  description: |
    Affected versions of [`com.fasterxml.jackson.core:jackson-databind`][1]
    are vulnerable to Deserialization of Untrusted Data. An attacker may
    exploit this issue by sending a maliciously crafted input to the
    `readValue` method of the `ObjectMapper`.

    # Details   {#details}

    Serialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][2]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][3]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://core.jackson.fasterxml.com
    [2]: https://cwe.mitre.org/data/definitions/502.html
    [3]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.1"
  - ">= 2.7.0 < 2.7.9.1"
  - ">= 2.8.0 < 2.8.9"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-7525
  cwe:
  - CWE-502
  disclosed_date: 2017-04-10
  created_date: 2017-09-14
  last_modified_date: 2017-09-14
  credit:
  - Liao Xinxi
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=1462702
  - https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1
  - https://github.com/FasterXML/jackson-databind/issues/1599
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:31573
  title: Deserialization of Untrusted Data
  description: |
    [`com.fasterxml.jackson.core:jackson-databind`][1] contains the
    general-purpose data-binding functionality and tree-model for Jackson
    Data Processor.

    Affected versions of the package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2]).



    [1]: https://core.jackson.fasterxml.com
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.1"
  - ">= 2.7.0 < 2.7.9.1"
  - ">= 2.8.0 < 2.8.10"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-15095
  cwe:
  - CWE-184
  disclosed_date: 2017-06-26
  created_date: 2017-11-09
  last_modified_date: 2017-11-09
  credit:
  - Liao Xinxi
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=1506612
  - https://github.com/FasterXML/jackson-databind/commit/e8f043d1
  - https://github.com/FasterXML/jackson-databind/commit/e8f043d1
  - https://github.com/FasterXML/jackson-databind/issues/1680
  - https://github.com/FasterXML/jackson-databind/issues/1737
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:32043
  title: Deserialization of Untrusted Data
  description: |
    [`com.fasterxml.jackson.core:jackson-databind`][1] contains the
    general-purpose data-binding functionality and tree-model for Jackson
    Data Processor.

    Affected versions of the package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2]). This is exploitable by sending maliciously crafted
    JSON input to the readValue method of the ObjectMapper, bypassing a
    blacklist that is ineffective if the Spring libraries are available in
    the classpath.



    [1]: https://core.jackson.fasterxml.com
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.8.11"
  - ">= 2.9.0 < 2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-17485
  cwe:
  - CWE-502
  disclosed_date: 2018-01-10
  created_date: 2018-01-22
  last_modified_date: 2018-01-22
  credit:
  - Imre Rad
  references:
  - http://www.securityfocus.com/archive/1/archive/1/541652/100/0/threaded
  - https://github.com/FasterXML/jackson-databind/issues/1855
  - https://github.com/irsl/jackson-rce-via-spel/
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:32044
  title: Deserialization of Untrusted Data
  description: |
    [`com.fasterxml.jackson.core:jackson-databind`][1] contains the
    general-purpose data-binding functionality and tree-model for Jackson
    Data Processor.

    Affected versions of the package are vulnerable to Deserialization of
    Untrusted Data due to an incomplete black list (incomplete fix for
    [CVE-2017-7525][2] and [CVE-2017-17485][3]). This is exploitable via two
    different gadgets that bypass a blacklist.



    [1]: https://core.jackson.fasterxml.com
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    [3]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.8.11"
  - ">= 2.9.0 < 2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-5968
  cwe:
  - CWE-502
  disclosed_date: 2018-01-18
  created_date: 2018-01-23
  last_modified_date: 2018-01-23
  credit:
  - Rui Chong
  references:
  - https://github.com/FasterXML/jackson-databind/issues/1899
  - https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:32111
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] contains the
    general-purpose data-binding functionality and tree-model for Jackson
    Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It allows unauthenticated remote code execution because
    of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is
    exploitable by sending maliciously crafted JSON input to the readValue
    method of the ObjectMapper, bypassing a blacklist that is ineffective if
    the `c3p0` libraries are available in the classpath.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.8.11.1"
  - ">= 2.9.0 < 2.9.5"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-7489
  cwe:
  - CWE-502
  disclosed_date: 2018-02-10
  created_date: 2018-02-26
  last_modified_date: 2018-02-26
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/issues/1931
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:450207
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered in FasterXML
    jackson-databind 2.x through 2.9.9. When Default Typing is enabled
    (either globally or for a specific property) for an externally exposed
    JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath,
    an attacker can send a specifically crafted JSON message that allows
    them to read arbitrary local files on the server.



    [1]: https://github.com/FasterXML/jackson-databind
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.4"
  - ">= 2.9.0 < 2.9.9.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-12814
  cwe:
  - CWE-502
  disclosed_date: 2019-06-19
  created_date: 2019-06-19
  last_modified_date: 2019-06-19
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5
  - https://github.com/FasterXML/jackson-databind/issues/2341
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:450917
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data which allows attackers to have a variety of impacts by
    leveraging failure to block the `logback-core` class from polymorphic
    deserialization. Depending on the `classpath` content, remote code
    execution may be possible.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.4"
  - ">= 2.9.0 < 2.9.9.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-12384
  cwe:
  - CWE-502
  disclosed_date: 2019-05-28
  created_date: 2019-06-25
  last_modified_date: 2019-06-25
  credit:
  - College of software Nankai University
  references:
  - https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x
  - https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java
  - https://github.com/FasterXML/jackson-databind/issues/2334
  - https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:455617
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. `SubTypeValidator.java` mishandles default typing when
    `ehcache` is used, leading to remote code execution.



    [1]: https://github.com/FasterXML/jackson-databind
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.6"
  - ">= 2.8.0 < 2.8.11.4"
  - ">= 2.9.0 < 2.9.9.2"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-14379
  - CVE-2019-14439
  cwe:
  - CWE-502
  disclosed_date: 2019-07-29
  created_date: 2019-07-29
  last_modified_date: 2019-07-29
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2
  - https://github.com/FasterXML/jackson-databind/issues/2387
  - https://github.com/FasterXML/jackson-databind/issues/2389
  - https://github.com/FasterXML/jackson-databind/issues/2395
  - https://snyk.io/blog/jackson-deserialization-vulnerability/
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:467014
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered as
    `com.zaxxer.hikari.HikariDataSource` was not blocked. **Note:** This is
    a different vulnerability than CVE-2019-14540.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  - ">= 2.10.0.pr1 < 2.10.0.pr3"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-16335
  cwe:
  - CWE-502
  disclosed_date: 2019-09-15
  created_date: 2019-09-16
  last_modified_date: 2019-09-16
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db
  - https://github.com/FasterXML/jackson-databind/issues/2449
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:467015
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered as
    `com.zaxxer.hikari.HikariConfig` was not blocked. **Note:** This is a
    different vulnerability than CVE-2019-16335.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  - ">= 2.10.0.pr1 < 2.10.0.pr2"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-14540
  cwe:
  - CWE-502
  disclosed_date: 2019-09-15
  created_date: 2019-09-16
  last_modified_date: 2019-09-16
  credit:
  - iSafeBlue
  references:
  - https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de
  - https://github.com/FasterXML/jackson-databind/issues/2410
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:467016
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered as
    `org.apache.cxf.jaxrs.provider.XSLTJaxbProvider` was not blocked. An
    attacker could leverage this gadget type to perform Remote Code
    Execution attacks through deserialization.

    **Note:** This is a different vulnerability than CVE-2019-14540.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  - ">= 2.10.0.pr1 < 2.10.0.pr2"
  severity: high
  package_manager: maven
  cwe:
  - CWE-502
  disclosed_date: 2019-09-16
  created_date: 2019-09-16
  last_modified_date: 2019-09-16
  credit:
  - Tatu Saloranta
  references:
  - https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de
  - https://github.com/FasterXML/jackson-databind/issues/2420
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:469674
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered within
    `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not
    blocked. An attacker could leverage this gadget type to perform Remote
    Code Execution attacks through deserialization.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-16942
  cwe:
  - CWE-502
  disclosed_date: 2019-10-01
  created_date: 2019-10-02
  last_modified_date: 2019-10-02
  credit:
  - bsmali4
  references:
  - https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac
  - https://github.com/FasterXML/jackson-databind/issues/2478
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:469676
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered as
    `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could
    leverage this gadget type to perform Remote Code Execution attacks
    through deserialization.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-16943
  cwe:
  - CWE-502
  disclosed_date: 2019-10-01
  created_date: 2019-10-02
  last_modified_date: 2019-10-02
  credit:
  - bsmali4
  references:
  - https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac
  - https://github.com/FasterXML/jackson-databind/issues/2478
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:471943
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A Polymorphic Typing issue was discovered related to
    `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.9.10"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-17267
  cwe:
  - CWE-502
  disclosed_date: 2019-10-07
  created_date: 2019-10-07
  last_modified_date: 2019-10-07
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb
  - https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10
  - https://github.com/FasterXML/jackson-databind/issues/2460
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:472980
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. When Default Typing is enabled for an externally exposed
    JSON endpoint and the service has the apache-log4j-extra (version 1.2.x)
    jar in the classpath, and an attacker can provide a JNDI service to
    access, it is possible to make the service execute a malicious payload.



    [1]: https://github.com/FasterXML/jackson-databind
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.9.10.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2019-17531
  cwe:
  - CWE-502
  disclosed_date: 2019-10-12
  created_date: 2019-10-13
  last_modified_date: 2019-10-13
  credit:
  - Zhangxianhui
  references:
  - https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0
  - https://github.com/FasterXML/jackson-databind/issues/2498
  - https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72445
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] contains the
    general-purpose data-binding functionality and tree-model for Jackson
    Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attack, if the user is handling untrusted content or using the `Default
    Typing` feature. an incomplete fix for the [CVE-2017-7525][2]
    deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-12022`) is not identical to
    `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14723` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.7.9.4"
  - ">= 2.8.0 < 2.8.11.2"
  - ">= 2.9.0 < 2.9.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-12022
  cwe:
  - CWE-502
  disclosed_date: 2018-05-29
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1
  - https://github.com/FasterXML/jackson-databind/issues/2052
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72446
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] contains the
    general-purpose data-binding functionality and tree-model for Jackson
    Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. It may allow content exfiltration (remote access by
    sending contents over ftp) when untrusted content is deserialized with
    default typing enabled. This vulnerability is due to an incomplete fix
    for the [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-11307`) is not identical to
    `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722` and `CVE-2018-14723`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0.RC1 < 2.7.9.4"
  - ">= 2.8.0.rc1 < 2.8.11.2"
  - ">= 2.9.0 < 2.9.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-11307
  cwe:
  - CWE-502
  disclosed_date: 2018-05-10
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737
  - https://github.com/FasterXML/jackson-databind/issues/2032
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72447
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] contains the
    general-purpose data-binding functionality and tree-model for Jackson
    Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attack, if the user is handling untrusted content or using the `Default
    Typing` feature. This vulnerability is due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-12023`) is not identical to
    `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0-RC1 < 2.7.9.4"
  - ">= 2.8.0.rc1 < 2.8.11.2"
  - ">= 2.9.0 < 2.9.6"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-12023
  cwe:
  - CWE-502
  disclosed_date: 2018-05-29
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a
  - https://github.com/FasterXML/jackson-databind/issues/2058
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72448
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] library which contains
    the general-purpose data-binding functionality and tree-model for
    Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks via the `slf4j-ext` gadget due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14718`) is not identical to
    `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14718
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72449
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform an XML External Entity (XXE)
    Injection via the `JDK` classes due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14720`) is not identical to
    `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14720
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72450
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] library which contains
    the general-purpose data-binding functionality and tree-model for
    Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution attack
    via the `blaze-ds-opt` gadget due to an incomplete fix for the
    [CVE-2017-7525][2] deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14719`) is not identical to
    `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14719
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72451
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] library which contains
    the general-purpose data-binding functionality and tree-model for
    Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. A malicious user could perform a SSRF attack via the
    `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525][2]
    deserialization flaw.

    **Note:** This vulnerability (`CVE-2018-14721`) is not identical to
    `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`,
    `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.



    [1]: https://github.com/FasterXML/jackson-databind
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - "< 2.6.7.2"
  - ">= 2.7.9 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.7"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-14721
  cwe:
  - CWE-502
  disclosed_date: 2018-07-27
  created_date: 2018-10-11
  last_modified_date: 2018-10-11
  credit:
  - Unknown
  references:
  - https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44
  - https://github.com/FasterXML/jackson-databind/issues/2097
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72882
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks due to not blocking the `jboss-common-core` class from
    polymorphic deserialization.

    **Note** This vulnerability (`CVE-2018-19362`) is not identical to
    `CVE-2018-19360` and `CVE-2018-19361`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.8"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-19362
  cwe:
  - CWE-502
  disclosed_date: 2019-01-02
  created_date: 2019-01-03
  last_modified_date: 2019-01-03
  credit:
  - Wuguixiong
  references:
  - https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b
  - https://github.com/FasterXML/jackson-databind/issues/2186
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72883
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks due to not blocking the `axis2-transport-jms` class from
    polymorphic deserialization.

    **Note** This vulnerability (`CVE-2018-19360`) is not identical to
    `CVE-2018-19362` and `CVE-2018-19361`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.8"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-19360
  cwe:
  - CWE-502
  disclosed_date: 2019-01-02
  created_date: 2019-01-03
  last_modified_date: 2019-01-03
  credit:
  - Wuguixiong
  references:
  - https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b
  - https://github.com/FasterXML/jackson-databind/issues/2186
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883
- id: snykio:maven:com.fasterxml.jackson.core:jackson-databind:72884
  title: Deserialization of Untrusted Data
  description: |
    [com.fasterxml.jackson.core:jackson-databind][1] is a library which
    contains the general-purpose data-binding functionality and tree-model
    for Jackson Data Processor.

    Affected versions of this package are vulnerable to Deserialization of
    Untrusted Data. An attacker could perform a Remote Code Execution
    attacks due to not blocking the `axis2-transport-jms` class from
    polymorphic deserialization.

    **Note** This vulnerability (`CVE-2018-19361`) is not identical to
    `CVE-2018-19362` and `CVE-2018-19360`.



    [1]: https://github.com/FasterXML/jackson-databind
    \nSerialization is a process of converting an object into a sequence of
    bytes which can be persisted to a disk or database or can be sent
    through streams. The reverse process of creating object from sequence of
    bytes is called deserialization. Serialization is commonly used for
    communication (sharing objects between multiple hosts) and persistence
    (store the object state in a file or a database). It is an integral part
    of popular protocols like *Remote Method Invocation (RMI)*, *Java
    Management Extension (JMX)*, *Java Messaging System (JMS)*, *Action
    Message Format (AMF)*, *Java Server Faces (JSF) ViewState*, etc.

    *Deserialization of untrusted data* ([CWE-502][1]), is when the
    application deserializes untrusted data without sufficiently verifying
    that the resulting data will be valid, letting the attacker to control
    the state or the flow of the execution.

    Java deserialization issues have been known for years. However, interest
    in the issue intensified greatly in 2015, when classes that could be
    abused to achieve remote code execution were found in a [popular library
    (Apache Commons Collection)][2]. These classes were used in zero-days
    affecting IBM WebSphere, Oracle WebLogic and many other products.

    An attacker just needs to identify a piece of software that has both a
    vulnerable class on its path, and performs deserialization on untrusted
    data. Then all they need to do is send the payload into the
    deserializer, getting the command executed.

    > Developers put too much trust in Java Object Serialization. Some even
    > de-serialize objects pre-authentication. When deserializing an Object
    > in Java you typically cast it to an expected type, and therefore
    > Java\'s strict type system will ensure you only get valid object
    > trees. Unfortunately, by the time the type checking happens, platform
    > code has already created and executed significant logic. So, before
    > the final type is checked a lot of code is executed from the
    > readObject() methods of various objects, all of which is out of the
    > developer\'s control. By combining the readObject() methods of various
    > classes which are available on the classpath of the vulnerable
    > application an attacker can execute functions (including calling
    > Runtime.exec() to execute local OS commands).

    * Apache Blog

    The vulnerability, also know as *Mad Gadget*

    > Mad Gadget is one of the most pernicious vulnerabilities we’ve seen.
    > By merely existing on the Java classpath, seven “gadget” classes in
    > Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0)
    > make object deserialization for the entire JVM process Turing complete
    > with an exec function. Since many business applications use object
    > deserialization to send messages across the network, it would be like
    > hiring a bank teller who was trained to hand over all the money in the
    > vault if asked to do so politely, and then entrusting that teller with
    > the key. The only thing that would keep a bank safe in such a
    > circumstance is that most people wouldn’t consider asking such a
    > question.

    * Google



    [1]: https://cwe.mitre.org/data/definitions/502.html
    [2]: https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - ">= 2.0.0 < 2.7.9.5"
  - ">= 2.8.0 < 2.8.11.3"
  - ">= 2.9.0 < 2.9.8"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-19361
  cwe:
  - CWE-502
  disclosed_date: 2019-01-02
  created_date: 2019-01-03
  last_modified_date: 2019-01-03
  credit:
  - Wuguixiong
  references:
  - https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b
  - https://github.com/FasterXML/jackson-databind/issues/2186
  - https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8
  source_url: https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2017-17485
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'FasterXML jackson-databind through 2.8.10 and 2.9.x through 2.9.3
    allows unauthenticated remote code execution because of an incomplete fix for
    the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously
    crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist
    that is ineffective if the Spring libraries are available in the classpath.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2.8'
  - '2.9'
  - "<=2.8.10"
  - "<=2.9.3"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.11"
  - ">=2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-17485
  credit:
  - Victims CVE Database
  references:
  - http://www.securityfocus.com/archive/1/archive/1/541652/100/0/threaded
  - https://access.redhat.com/errata/RHSA-2018:0116
  - https://access.redhat.com/errata/RHSA-2018:0342
  - https://access.redhat.com/errata/RHSA-2018:0478
  - https://access.redhat.com/errata/RHSA-2018:0479
  - https://access.redhat.com/errata/RHSA-2018:0480
  - https://access.redhat.com/errata/RHSA-2018:0481
  - https://access.redhat.com/errata/RHSA-2018:1447
  - https://access.redhat.com/errata/RHSA-2018:1448
  - https://access.redhat.com/errata/RHSA-2018:1449
  - https://access.redhat.com/errata/RHSA-2018:1450
  - https://access.redhat.com/errata/RHSA-2018:1451
  - https://github.com/FasterXML/jackson-databind/issues/1855
  - https://github.com/irsl/jackson-rce-via-spel/
  - https://security.netapp.com/advisory/ntap-20180201-0003/
  - https://www.debian.org/security/2018/dsa-4114
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2017/17485.yaml
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2017-7525
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'A deserialization flaw was discovered in the jackson-databind which
    could allow an unauthenticated user to perform code execution by sending the maliciously
    crafted input to the readValue method of the ObjectMapper.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2'
  - '2.8'
  - '2.9'
  - "<=2.7.0"
  - "<=2.8.9"
  - "<=2.9.0"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.10"
  - ">=2.9.1"
  severity: high
  package_manager: maven
  cve:
  - CVE-2017-7525
  credit:
  - Victims CVE Database
  references:
  - https://bugzilla.redhat.com/show_bug.cgi?id=1462702
  - https://github.com/FasterXML/jackson-databind/issues/1737
  - https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2017/7525.yaml
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2018-5968
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'FasterXML jackson-databind through 2.8.11 and 2.9.x through 2.9.3
    allows unauthenticated remote code execution because of an incomplete fix for
    the CVE-2017-7525 and CVE-2017-17485 deserialization flaws. This is exploitable
    via two different gadgets that bypass a blacklist.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2.8'
  - '2.9'
  - "<=2.8.11"
  - "<=2.9.3"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.11.1"
  - ">=2.9.4"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-5968
  credit:
  - Victims CVE Database
  references:
  - https://access.redhat.com/errata/RHSA-2018:0478
  - https://access.redhat.com/errata/RHSA-2018:0479
  - https://access.redhat.com/errata/RHSA-2018:0480
  - https://access.redhat.com/errata/RHSA-2018:0481
  - https://access.redhat.com/errata/RHSA-2018:1525
  - https://github.com/FasterXML/jackson-databind/issues/1899
  - https://security.netapp.com/advisory/ntap-20180423-0002/
  - https://www.debian.org/security/2018/dsa-4114
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2018/5968.yaml
- id: victims:maven:com.fasterxml.jackson.core:jackson-databind:2018-7489
  title: 'jackson-databind: Deserialization vulnerability via readValue method of
    ObjectMapper'
  description: 'FasterXML jackson-databind before 2.8.11.1 and 2.9.x before 2.9.5
    allows unauthenticated remote code execution because of an incomplete fix for
    the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously
    crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist
    that is ineffective if the c3p0 libraries are available in the classpath.

'
  affected_package: com.fasterxml.jackson.core:jackson-databind
  vulnerable_versions:
  - '2.8'
  - '2.9'
  - "<2.8.11.1"
  - "<=2.9.4"
  patched_versions:
  - '2.8'
  - '2.9'
  - ">=2.8.11.1"
  - ">=2.9.5"
  severity: high
  package_manager: maven
  cve:
  - CVE-2018-7489
  credit:
  - Victims CVE Database
  references:
  - http://www.oracle.com/technetwork/security-advisory/cpuapr2018-3678067.html
  - http://www.securityfocus.com/bid/103203
  - http://www.securitytracker.com/id/1040693
  - https://access.redhat.com/errata/RHSA-2018:1447
  - https://access.redhat.com/errata/RHSA-2018:1448
  - https://access.redhat.com/errata/RHSA-2018:1449
  - https://access.redhat.com/errata/RHSA-2018:1450
  - https://access.redhat.com/errata/RHSA-2018:1451
  - https://access.redhat.com/errata/RHSA-2018:1786
  - https://github.com/FasterXML/jackson-databind/issues/1931
  - https://security.netapp.com/advisory/ntap-20180328-0001/
  - https://www.debian.org/security/2018/dsa-4190
  source_url: https://github.com/victims/victims-cve-db/blob/master/database/java/2018/7489.yaml
